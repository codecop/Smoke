#!/usr/bin/env ruby

GREEN = "\e[32m"
RED = "\e[31m"
RESET = "\e[0m"

SPECIAL = '#;&."\',\\/`:!*?$*(){}[]><|~'.chars

def escape args
  args.chars.collect { |c| SPECIAL.include?(c) ? '\\' + c : c }.join
end

def run_application application, args, input
  IO.popen "#{unescape(application)} #{escape args}", 'r+' do |io|
    io.write input
    io.close_write
    io.read.strip
  end
end

def read_tests test_case
  in_files = Dir.glob("#{test_case}/*.in").collect { |file| [File.basename(file, '.in'), :input, file] }
  args_files = Dir.glob("#{test_case}/*.args").collect { |file| [File.basename(file, '.args'), :args, file] }
  tests = (in_files + args_files).group_by { |name, type, file| name }.collect { |name, files|
    [name, files.collect { |filename, type, file| [type, IO.read(file).strip] }]
  }.sort_by { |name, _| name }

  tests.collect { |name, types|
    potential_args = types.find { |type, contents| type == :args }
    args = potential_args ? potential_args[1] : ''
    potential_input = types.find { |type, contents| type == :input }
    input = potential_input ? potential_input[1] : ''

    output_files = Dir.glob "#{test_case}/#{name}.out*"
    expected = output_files.collect do |output_file|
      IO.read(output_file).strip
    end

    [name, args, input, expected]
  }
end

def run_tests tests, application
  tests.each do |testname, args, input, expected|
    puts testname
    next failed "no outputs provided" if expected.length == 0

    output = run_application application, args, input

    next failed "program exited with status code #{$?}" if $?.exitstatus > 0

    unless expected.include? output
      expected = expected.collect { |e| highlight(e) }
      info = []
      info << ['args', highlight(args)] unless args.empty?
      info << ['input', highlight(input)] unless input.empty?
      info << ['output', highlight(output)]
      info << ['expected', expected.length == 1 ? expected[0] :
                               "#{expected[0...expected.length - 1].join(', ')} or #{expected[-1]}"]

      next failed(*(info.collect { |name, value| Kernel.format '%-9s %s', (name + ':'), value }))
    end

    succeeded 'succeeded'
  end
end

def print_summary
  puts
  if @failures > 0
    puts red "#{@successes + @failures} tests, #{@failures} failures"
  else
    puts green "#{@successes + @failures} tests, #{@failures} failures"
  end
end

def green string
  "#{GREEN}#{string}#{RESET}"
end

def red string
  "#{RED}#{string}#{RESET}"
end

@successes = 0
def succeeded *messages
  puts green messages.collect { |message| '  ' + message }.join "\n"
  @successes += 1
end

@failures = 0
def failed *messages
  puts red messages.collect { |message| '  ' + message }.join "\n"
  @failures += 1
end

def highlight text
  highlighted = text.include?("\e") ? (RESET + text + RED) : text
  highlighted.gsub("\n", "\n            ")
end

def unescape filename
  filename.gsub(/\\\//, File::SEPARATOR).
           sub(/\\\./, '.')
end

run_tests(read_tests(unescape(ARGV[0])), ARGV[1])
print_summary
